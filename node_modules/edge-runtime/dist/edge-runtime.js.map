{"version":3,"file":"edge-runtime.js","sourceRoot":"","sources":["../src/edge-runtime.ts"],"names":[],"mappings":";;;AAEA,yCAAyC;AAWzC;;;GAGG;AACH,IAAI,0BAA8C,CAAA;AAClD,IAAI,yBAAyC,CAAA;AAE7C;;;;GAIG;AACH,MAAa,WAEX,SAAQ,WAAS;IAGjB,YAAY,OAAoB;QAC9B,KAAK,CAAC;YACJ,GAAG,OAAO;YACV,MAAM,EAAE,CAAC,OAAO,EAAE,EAAE;;gBAClB,OAAO,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,wDAAG,OAAO,CAAC,mCAAK,OAA2B,CAAA;YACnE,CAAC;SACF,CAAC,CAAA;QAEF,kBAAkB,CAAC;YACjB,MAAM,EAAE,IAAI;YACZ,UAAU,EAAE,+BAA+B;YAC3C,MAAM,EAAE,CAAC,QAA4B,EAAE,EAAE,CACvC,CAAC,0BAA0B,GAAG,QAAQ,CAAC;YACzC,UAAU,EAAE,qBAAqB;YACjC,MAAM,EAAE,GAAG,EAAE,CAAC,0BAA0B;SACzC,CAAC,CAAA;QACF,kBAAkB,CAAC;YACjB,MAAM,EAAE,IAAI;YACZ,UAAU,EAAE,kBAAkB;YAC9B,MAAM,EAAE,CAAC,QAAwB,EAAE,EAAE,CACnC,CAAC,yBAAyB,GAAG,QAAQ,CAAC;YACxC,UAAU,EAAE,iBAAiB;YAC7B,MAAM,EAAE,GAAG,EAAE,CAAC,yBAAyB;SACxC,CAAC,CAAA;QAEF,IAAI,CAAC,QAAQ,CAAO,2BAA2B,EAAE,CAAC,CAAA;QAClD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAgB,oBAAoB,EAAE,CAAC,CAAA;QACzE,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,EAAE;YACxB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAA;SACnC;IACH,CAAC;CACF;AApCD,kCAoCC;AAED;;;GAGG;AACH,OAAO,CAAC,EAAE,CACR,oBAAoB,EACpB,SAAS,uBAAuB,CAAC,MAAM,EAAE,OAAO;IAC9C,0BAA0B,aAA1B,0BAA0B,uBAA1B,0BAA0B,CAAE,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAC9C,OAAO,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAC7B,CAAA;AACH,CAAC,CACF,CAAA;AACD,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,SAAS,mBAAmB,CAAC,KAAK;IAChE,yBAAyB,aAAzB,yBAAyB,uBAAzB,yBAAyB,CAAE,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAA;AACjE,CAAC,CAAC,CAAA;AAEF;;;;;;GAMG;AACH,SAAS,2BAA2B;IAClC,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCN,CAAA;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,oBAAoB;IAC3B,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAoCJ,CAAA;AACL,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB,CAAC,EAC1B,MAAM,EAAE,QAAQ,EAChB,UAAU,EACV,MAAM,EAAE,MAAM,EACd,UAAU,EACV,MAAM,GAOP;IACC,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,EAAE;QAClD,GAAG,EAAE,MAAM;QACX,YAAY,EAAE,KAAK;QACnB,UAAU,EAAE,KAAK;KAClB,CAAC,CAAA;IAEF,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,UAAU,EAAE;QAC1C,GAAG,EAAE,MAAM;QACX,YAAY,EAAE,KAAK;QACnB,UAAU,EAAE,KAAK;KAClB,CAAC,CAAA;AACJ,CAAC","sourcesContent":["import type { DispatchFetch, ErrorHandler, RejectionHandler } from './types'\nimport type { EdgeVMOptions, EdgeContext } from '@edge-runtime/vm'\nimport { EdgeVM } from '@edge-runtime/vm'\n\ninterface Options<T extends EdgeContext> extends EdgeVMOptions<T> {\n  /**\n   * Code to be evaluated as the VM for the Runtime is created. This is handy\n   * to run code directly instead of first creating the runtime and then\n   * evaluating.\n   */\n  initialCode?: string\n}\n\n/**\n * Store handlers that the user defined from code so that we can invoke them\n * from the Node.js realm.\n */\nlet unhandledRejectionHandlers: RejectionHandler[]\nlet uncaughtExceptionHandlers: ErrorHandler[]\n\n/**\n * An EdgeVM that also allows to add and remove event listeners for unhandled\n * rejections and FetchEvent. It also allows to dispatch fetch events which\n * enables it to work behind a server.\n */\nexport class EdgeRuntime<\n  T extends EdgeContext = EdgeContext\n> extends EdgeVM<T> {\n  public readonly dispatchFetch: DispatchFetch\n\n  constructor(options?: Options<T>) {\n    super({\n      ...options,\n      extend: (context) => {\n        return options?.extend?.(context) ?? (context as EdgeContext & T)\n      },\n    })\n\n    defineHandlerProps({\n      object: this,\n      setterName: '__onUnhandledRejectionHandler',\n      setter: (handlers: RejectionHandler[]) =>\n        (unhandledRejectionHandlers = handlers),\n      getterName: '__rejectionHandlers',\n      getter: () => unhandledRejectionHandlers,\n    })\n    defineHandlerProps({\n      object: this,\n      setterName: '__onErrorHandler',\n      setter: (handlers: ErrorHandler[]) =>\n        (uncaughtExceptionHandlers = handlers),\n      getterName: '__errorHandlers',\n      getter: () => uncaughtExceptionHandlers,\n    })\n\n    this.evaluate<void>(getDefineEventListenersCode())\n    this.dispatchFetch = this.evaluate<DispatchFetch>(getDispatchFetchCode())\n    if (options?.initialCode) {\n      this.evaluate(options.initialCode)\n    }\n  }\n}\n\n/**\n * Define system-level handlers to make sure that we report to the user\n * whenever there is an unhandled rejection or exception before the process crashes.\n */\nprocess.on(\n  'unhandledRejection',\n  function invokeRejectionHandlers(reason, promise) {\n    unhandledRejectionHandlers?.forEach((handler) =>\n      handler({ reason, promise })\n    )\n  }\n)\nprocess.on('uncaughtException', function invokeErrorHandlers(error) {\n  uncaughtExceptionHandlers?.forEach((handler) => handler(error))\n})\n\n/**\n * Generates polyfills for addEventListener and removeEventListener. It keeps\n * all listeners in hidden property __listeners. It will also call a hook\n * `__onUnhandledRejectionHandler` and `__onErrorHandler` when unhandled rejection\n * events are added or removed and prevent from having more than one FetchEvent\n * handler.\n */\nfunction getDefineEventListenersCode() {\n  return `\n    Object.defineProperty(self, '__listeners', {\n      configurable: false,\n      enumerable: false,\n      value: {},\n      writable: true,\n    })\n\n    function __conditionallyUpdatesHandlerList(eventType) {\n      if (eventType === 'unhandledrejection') {\n        self.__onUnhandledRejectionHandler = self.__listeners[eventType];\n      } else if (eventType === 'error') {\n        self.__onErrorHandler = self.__listeners[eventType];\n      }\n    }\n\n    function addEventListener(type, handler) {\n      const eventType = type.toLowerCase();\n      if (eventType === 'fetch' && self.__listeners.fetch) {\n        throw new TypeError('You can register just one \"fetch\" event listener');\n      }\n\n      self.__listeners[eventType] = self.__listeners[eventType] || [];\n      self.__listeners[eventType].push(handler);\n      __conditionallyUpdatesHandlerList(eventType);\n    }\n\n    function removeEventListener(type, handler) {\n      const eventType = type.toLowerCase();\n      if (self.__listeners[eventType]) {\n        self.__listeners[eventType] = self.__listeners[eventType].filter(item => {\n          return item !== handler;\n        });\n\n        if (self.__listeners[eventType].length === 0) {\n          delete self.__listeners[eventType];\n        }\n      }\n      __conditionallyUpdatesHandlerList(eventType);\n    }\n  `\n}\n\n/**\n * Generates the code to dispatch a FetchEvent invoking the handlers defined\n * for such events. In case there is no event handler defined it will throw\n * an error.\n */\nfunction getDispatchFetchCode() {\n  return `(async function dispatchFetch(input, init) {\n    const request = new Request(input, init);\n    const event = new FetchEvent(request);\n    if (!self.__listeners.fetch) {\n      throw new Error(\"No fetch event listeners found\");\n    }\n\n    const getResponse = ({ response, error }) => {\n     if (error || !response || !(response instanceof Response)) {\n        console.error(error ? error.toString() : 'The event listener did not respond')\n        response = new Response(null, {\n          statusText: 'Internal Server Error',\n          status: 500\n        })\n      }\n\n      response.waitUntil = () => Promise.all(event.awaiting);\n\n      if (response.status < 300 || response.status >= 400 ) {\n        response.headers.delete('content-encoding');\n        response.headers.delete('transform-encoding');\n        response.headers.delete('content-length');\n      }\n\n      return response;\n    }\n\n    try {\n      await self.__listeners.fetch[0].call(event, event)\n    } catch (error) {\n      return getResponse({ error })\n    }\n\n    return Promise.resolve(event.response)\n      .then(response => getResponse({ response }))\n      .catch(error => getResponse({ error }))\n  })`\n}\n\n/**\n * Defines a readable property on the VM and the corresponding writable property\n * on the VM's context. These properties are not enumerable nor updatable.\n */\nfunction defineHandlerProps({\n  object: instance,\n  setterName,\n  setter: setter,\n  getterName,\n  getter,\n}: {\n  object: EdgeRuntime\n  setterName: string\n  setter: (_: any) => void\n  getterName: string\n  getter: () => any\n}) {\n  Object.defineProperty(instance.context, setterName, {\n    set: setter,\n    configurable: false,\n    enumerable: false,\n  })\n\n  Object.defineProperty(instance, getterName, {\n    get: getter,\n    configurable: false,\n    enumerable: false,\n  })\n}\n"]}